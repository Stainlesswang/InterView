# union熔断方案

接口API: 
`batchGetClusterItemDetailsByUidAndClusterType`
根据uid+视频集类型获取视频集中item详细信息

接口SLA 300ms 超过300ms阈值的单机QPS为= XX

设置想留熔断器,当超过XX阈值的时候,请求直接拒掉,可以使用一个RateLimiter来做个限流即可

现象: 热点情况下,根据多个uid获取对应视频集的时候会有很大的扇出,造成读扩散,
正常情况下

日常情况下视频集db单端口 QPS 1.2K(晚高峰)

9月16号高峰 出现DB单端口 QPS 30k   单看DB的 接口QPS峰值8k左右

1. 梳理下业务方的调用来源
2. 增加熔断,如果db或者缓存慢了,不可用的话,该接口增加熔断器
3. 增加限流, 此举是为了保护db, 限流是单机限流还是分布式限流?


    缓存常见的使用方式
1. 旁路缓存
    1. 写入DB -> 删除cache 结束
    2. 读数据-> 未命中缓存 -> 查DB -> 写缓存
    3. 读数据-> 命中缓存 -> return

    有可能存在的问题:
    - 多个请求请求一个key, 缓存击穿 ()
    - 线程A查DB-> 写缓存的过程中, 线程B更新数据成功,导致cache和DB不一致, ()
2. 读写穿缓存
    1. 入db -> 更新缓存 -> return
    2. 读数据 -> 未命中 -> 查DB -> 写缓存
    3. 读数据 -> 命中 -> return
3. 延迟更新db
    1. 写缓存 -> return
    2. 读数据 -> 未命中 -> 查DB -> 写缓存 -> return
    3. 读数据 -> 命中 -> return
    4. 异步线程从cache写入D