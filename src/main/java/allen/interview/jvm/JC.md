# JC Question


1. **JC分代回收结构**

  分代回收主要分为**新生代,老年代**; 其中新生代 又可以细分为 `Eden空间`,`From Survivor`,`To Survivor`,java在分配新对象的时候会在Eden上边进行创建, 后边的两块主要是在**Minor GC**(新生代的垃圾回收比FUll GC要快和频繁) 
  
  大对象直接进入老年代(防止发生**分配担保机制**出现大量数据的复制转移),存活时间较长的进入老年代,会有一个Age来记录对象的存活代数
  
  分配担保机制,就是在新生代中发现没办法为新的对象提供空间的时候,把在Eden上的对象复制到老年代上的操作, 作为一个担保,来保证对象有空间分配到新生代中
  
2. **如何判断一个对象是否存活?**

  两张方法判断一个对象是否存
  
  - 引用计数器法: 有对象引用+1,不用了-1  无法解决循环引用的问题,会导致互相引用对方而双方都无法被回收的现象
  - 可达性分析法: 一系列的`GCRoot Set`作为根,然后向外延伸的引用树, 若果这些树中有的没有连接上这个ROOT的话就被判定是不可达的

3. **引用的分级**

  - 强引用:只要是可达的对象,就算OOM了也不回收
  - 软引用:实在没空间了,会优先回收弱引用
  - 弱引用:每次GC都会回收
  - 虚引用:形同虚设,但虚引用会保存相应的虚引用队列中
  
4. **常量如何判断是否可用?**

  例如常量"abc"发现没有任何的String引用该字符串常量的话,就判定可回收
  
5. **如何判断一个类是无用的类**

  类主要是在方法区,判断一个类是否无用十分严格,分一下三种,只有满足了这三种才判断该类是无用的
  
  - 所有该类的对象实例在堆上都被回收了
  - 该类对应的ClassLoader也被回收了
  - 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法.

6. **GC回收算法**

  1. 标记-清除:对需要回收的进行标记,然后回收(适合回收少量对象使用, 因为这个方法会产生内存碎片)
  2. 标记-整理:标记过程不变,标记后首先把存活的移动到一起,分出界限,然后将存活的对象保留,清除需要回收的
  3. 复制:开辟出另外的相同大小的空间,把存活的对象复制过去,然后本区域全部回收
  4. 分代收集:根据 **新生代回收大量对象,老年代回收较少对象**这个特点,不同年代使用不同的垃圾回收算法来保证高效的垃圾回收. 新生代大部分都是要死的,存活的仅仅是少量的,我们可以选择**复制算法**,只需要将少量的存活对象移动走,剩下的全部回收即可, 老年代的话,使用复制太浪费空间,就可以使用**标记-整理算法**