# 数据库优化相关问题
-----

## 1.什么是索引?

索引是为了快速定位到数据的一种字典,生活中的书籍的目录,图书的检索列表,都是随处可见的,在茫茫的数据海洋当中,没有索引是非常可怕的.索引可以从10亿数据比较三十次左右就可以筛选出来我们想要的数据,这是非常令人震惊的.

提到索引呢,不得不提**B树和B+树**
  
  - **B+树:**
  ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/7af22798.jpg) 因为磁盘IO的速度是十分慢的,这是时间消耗的罪魁祸首,所以,使用B+树这种平衡二叉树采用类似于二分法的方式每次取出**一页**的数据

  拿表中的数据查找29举例
    
    1. 首先取出来磁盘快1,比较29在17和35中间
    2. 然后取 磁盘块3 比较29 在26和30中间
    3. 取出磁盘块8,得到29
  
  我们要注意的是,在B+树中只有叶子节点是存储真正的数据的,中间的层的节点存储的是对应关系和指向子节点的指针(**类似我们的目录结构中的文件夹,只是一个路径而已,指向应该去哪里**)
  
  - **B树**

    B树和B+树是相同的结构,但是不同之处是,真是数据并不是全部在叶子节点,也就是非叶子节点中保存的数据会多,这样会导致树的高度增加,进而在查询相同数据的时候磁盘IO次数增多,导致查询定位数据时间增加

--    
    
#### 索引中的几大原则:

1. **最左匹配原则:** MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。如有索引(a, b, c, d)，查询条件a = 1 and b = 2 and c > 3 and d = 4，则会在每个节点依次命中a、b、c，而无法命中d。(很简单：索引命中只能是相等的情况，不能是范围匹配)
2. **=和IN可以乱序:**比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
3. **尽量选择高区分度的列建索引:**也就是尽量选择字段简单,没有重复的列作为索引(例如主键的区分度就很高,没有重复)
4. **索引列不能参与计算,保持'干净':**索引保存的什么样,就直接拿该字段查找,防止每个都要计算后增加时间.
5. **尽量扩展索引,不要新建索引:**比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
6. **索引尽量设置为NOT NULL:**尽量使用0,或者特殊的默认值替代null,因为出现null会增加计算的复杂度
7. **表表连接的字段要建索引:**两个表连接的字段类型也必须一样,不然就会造成类型强转,造成无法命中索引
6. **负向查询不命中索引:** 

  不命中: ``select account FROM user WHERE id NOT IN(1,2,3)`` 
  
  命 中:  ``select account FROM user WHERE id IN(4,5,6)``
7. **前置模糊查询不命中索引:**

   不命中: ``select account FROM user WHERE name LIKE '%allen'`` 
  
  命 中:  ``select account FROM user WHERE name LIKE 'allen%' ``
  
6. **慎用group by,理解出现临时表的情况:** 
  -  如果GROUP BY 的列没有索引,产生临时表. 
  2. 如果GROUP BY时,SELECT的列不止GROUP BY列一个,并且GROUP BY的列不是主键 ,产生临时表. 
  3. 如果GROUP BY的列有索引,ORDER BY的列没索引.产生临时表. 
  4. 如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表. 
  5. 如果GROUP BY或ORDER BY的列不是来自JOIN语句第一个表.会产生临时表. 
  6. 如果DISTINCT 和 ORDER BY的列没有索引,产生临时表.

7. **内联表查询的过程:**

  1. 执行FROM语句
  2. 执行ON过滤
  3. 添加外部行
  4. 执行WHERE条件过滤
  5. 执行GROUP BY分组语句
  6. 执行having筛选
  7. select列表
  8. 执行distinct去除重复数据
  9. 执行order by语句
  10. 执行limit语句


---

## 2.Mysql大表优化

mysql当单表数据过大的时候,会出现读写效率变慢的情况,当数据量达到千万或者亿级别的数据量的时候,就要想办法优化mysql的存储,来提升性能