# 数据库优化相关问题
-----

## 1.什么是索引?

索引是为了快速定位到数据的一种字典,生活中的书籍的目录,图书的检索列表,都是随处可见的,在茫茫的数据海洋当中,没有索引是非常可怕的.索引可以从10亿数据比较三十次左右就可以筛选出来我们想要的数据,这是非常令人震惊的.

提到索引呢,不得不提**B树和B+树**
  
  - **B+树:**
  ![](https://awps-assets.meituan.net/mit-x/blog-images-bundle-2014/7af22798.jpg) 
  
  因为磁盘IO的速度是十分慢的,这是时间消耗的罪魁祸首,所以,使用B+树这种平衡二叉树采用类似于二分法的方式每次取出**一页**的数据

  拿表中的数据查找29举例
    
    1. 首先取出来磁盘快1,比较29在17和35中间
    2. 然后取 磁盘块3 比较29 在26和30中间
    3. 取出磁盘块8,得到29
  
  我们要注意的是,在B+树中只有叶子节点是存储真正的数据的,中间的层的节点存储的是对应关系和指向子节点的指针(**类似我们的目录结构中的文件夹,只是一个路径而已,指向应该去哪里**)
  
  - **B树**

    B树和B+树是相同的结构,但是不同之处是,真是数据并不是全部在叶子节点,也就是非叶子节点中保存的数据会多,这样会导致树的高度增加,进而在查询相同数据的时候磁盘IO次数增多,导致查询定位数据时间增加

  - **什么是聚簇索引? 非聚簇索引?**

    InnoDB中的是**聚簇索引**,索引本身就是数据存储本身,B+Tree的叶子节点就是存放整行数据的地方. 如果查找的是主索引,则直接查找出对应数据,若查找的是辅助索引,首先根据辅助索引get到对应的主索引,然后按照主索引流程取出数据
    MyISAM中的是**非聚簇索引**,其叶子节点保存的是数据地址,查找过程中首先根据主索引或者辅助索引查找出数据地址,然后根据地址去磁盘拿相应的记录
  
--    
    
#### 索引中的几大原则:

1. **最左匹配原则:** MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配。如有索引(a, b, c, d)，查询条件a = 1 and b = 2 and c > 3 and d = 4，则会在每个节点依次命中a、b、c，而无法命中d。(很简单：索引命中只能是相等的情况，不能是范围匹配)
2. **=和IN可以乱序:**比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
3. **尽量选择高区分度的列建索引:**也就是尽量选择字段简单,没有重复的列作为索引(例如主键的区分度就很高,没有重复)
4. **索引列不能参与计算,保持'干净':**索引保存的什么样,就直接拿该字段查找,防止每个都要计算后增加时间.
5. **尽量扩展索引,不要新建索引:**比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
6. **索引尽量设置为NOT NULL:**尽量使用0,或者特殊的默认值替代null,因为出现null会增加计算的复杂度
7. **表表连接的字段要建索引:**两个表连接的字段类型也必须一样,不然就会造成类型强转,造成无法命中索引
6. **负向查询不命中索引:** 

  不命中: ``select account FROM user WHERE id NOT IN(1,2,3)`` 
  
  命 中:  ``select account FROM user WHERE id IN(4,5,6)``
7. **前置模糊查询不命中索引:**

   不命中: ``select account FROM user WHERE name LIKE '%allen'`` 
  
  命 中:  ``select account FROM user WHERE name LIKE 'allen%' ``
  
6. **慎用group by,理解出现临时表的情况:** 
  -  如果GROUP BY 的列没有索引,产生临时表. 
  2. 如果GROUP BY时,SELECT的列不止GROUP BY列一个,并且GROUP BY的列不是主键 ,产生临时表. 
  3. 如果GROUP BY的列有索引,ORDER BY的列没索引.产生临时表. 
  4. 如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表. 
  5. 如果GROUP BY或ORDER BY的列不是来自JOIN语句第一个表.会产生临时表. 
  6. 如果DISTINCT 和 ORDER BY的列没有索引,产生临时表.

7. **内联表查询的过程:**

  1. 执行FROM语句
  2. 执行ON过滤
  3. 添加外部行
  4. 执行WHERE条件过滤
  5. 执行GROUP BY分组语句
  6. 执行having筛选
  7. select列表
  8. 执行distinct去除重复数据
  9. 执行order by语句
  10. 执行limit语句


---

## 2.Mysql大表优化

mysql当单表数据过大的时候,会出现读写效率变慢的情况,当数据量达到千万或者亿级别的数据量的时候,就要想办法优化mysql的存储,来提升性能

1. 分区:
  
  MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引


2. 垂直拆分:

  垂直分库是根据数据库里面的**数据表的业务相关性**进行拆分，比如：一个数据库里面既存在用户数据，又存在订单数据，那么垂直拆分可以把用户数据放到用户库、把订单数据放到订单库。垂直分表是对数据表进行垂直拆分的一种方式，常见的是把一个多字段的大表按常用字段和非常用字段进行拆分，每个表里面的数据记录数一般情况下是相同的，只是字段不一样，使用主键关联

3. 水平拆分:

  水平拆分是通过某种策略将数据分片来存储，分库内分表和分库两部分，每片数据会分散到不同的MySQL表或库，达到分布式的效果，能够支持非常大的数据量。前面的表分区本质上也是一种特殊的库内分表
库内分表，仅仅是单纯的解决了单一表数据过大的问题，由于没有把表的数据分布到不同的机器上，因此对于减轻MySQL服务器的压力来说，并没有太大的作用，大家还是竞争同一个物理机上的IO、CPU、网络，这个就要通过分库来解决

  **数据库分片会存在中间件或者客户端代理实现,具体实现方案比较:[mysql大表优化](https://segmentfault.com/a/1190000006158186)**

  记录一种分片优化下一种ID生成策略: 其中ID的组成为: **总共长度为64位**
  
  |第一部分|第二部分|第三部分| 
  |:-----:|:----:|:----:|
  |从某个时间点开始的秒数(长度为36位)|shard的ID(长度为13位,也就是支持8192个shards)|mysql(长度为15位,最大为32768)|
  
  - 整个ID 的二进制长度为64 位
  - 前 36 位使用时间戳，以保证 ID 是升序增加
  - 中间 13 位是分库标识，用来标识当前这个 ID 对应的记录在哪个数据库中
  - 后 15 位为自增序列，以保证在同一秒内并发时，ID 不会重复。每个 shard 库都有一个自增序列表，生成自增序列时，从自增序列表中获取当前自增序列值，并加 1，做为当前 ID 的后 15 位



4. 读写分离:

  也是目前常用的优化，从库读主库写，一般不要采用双主或多主引入很多复杂性，尽量采用文中的其他方案来提高性能。同时目前很多拆分的解决方案同时也兼顾考虑了读写分离
