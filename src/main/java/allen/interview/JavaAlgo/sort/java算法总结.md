###1. 常见的八种排序算法

| 排序方法	 | 平均时间| 最好时间	|最坏时间
|:-------|:-------:| :-------:| :------:|
|桶排序(不稳定)	|O(n)	|O(n)	|O(n)
|基数排序(稳定)	|O(n)	|O(n)	|O(n)
|归并排序(稳定)	 |O(nlogn)	|O(nlogn)|	O(nlogn)
|快速排序(不稳定)|	O(nlogn)	|O(nlogn)	|O(n^2)
|堆排序(不稳定)	|O(nlogn)	|O(nlogn)	|O(nlogn)
|希尔排序(不稳定)	|O(n^1.25)	 	 
|冒泡排序(稳定)	|O(n^2)	|O(n)	|O(n^2)
|选择排序(不稳定)|O(n^2)	|O(n^2)	|O(n^2)
|直接插入排序(稳定)	|O(n^2)|	O(n)	|O(n^2)
* 插入类排序

  * 直接插入排序:将待排序分为两部分,已排序和未排序的. 依次遍历元素,将当前元素插入到已排序的合适位置
    
    时间复杂度为O(n^2)  最好情况下O(n)*当数组有序的时候,不用循环遍历已排序元素,直接循环一次外层就结束*
    
  * shell排序：指定间隔，分组进行直接插入排序，逐步减小间隔,**优化直接插入排序一次只能改变一个逆序**
  
* 选择类排序
  * 直接选择排序：比较并记录待排序记录中最小的位置，然后同待排序元素首位互换

    时间复杂度为O(n^2)
    
  * 堆排序:用数组来标的的**完全二叉树**的存储,保证
 
  
*  交换类排序

   * 冒泡排序：依次比较，小的往后移，像冒泡泡一样 

     时间复杂度为**O(n^2)**,最好的情况下(设置一个有序标识,遍历一次后若有序则为**O(n))**
   * 快速排序：选择基数，左指针找比基数小的，右指针找大的，然后互换位置，继续找直到相遇，将基数同相遇位置互换
	
	  时间复杂度:
   
* 归并排序 :分而治之的思想运用，将大数组分为若干个小数组分别进行排序，然后将结果合并 见本包下Up2DownMergeSort 和 Down2UpMergeSort
* 基数排序 ：按照**个位/十位/百位...**分别进行如下操作: 该位上数字相同的移动到一个桶里,然后分别从桶里依次串联.这样在最高位执行完以后,整个数列就是有序的