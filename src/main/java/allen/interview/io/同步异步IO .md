# 什么是IO? 相信是很多初级程序员十分头疼的一些概念

我们从解决问题的概念去循序渐进的去解决每个IO模型出现的问题,我们要知道IO就是Input/Output可以说是计算机的本质,假设你的计算机
不接受任何输入输出,那不就是一台会发光的固态硬盘么?可能计算器都不如

从程序的角度来讲,每个程序运行都是有每个程序用户态的虚拟内存的,它不能和计算机的内核态做信息的交换(例如网卡, 磁盘等),那么当
程序发生一次IO请求只能委托系统发起一个调用的请求,然后该请求去调用内核态做数据的准备,并且准备好还需要将数据从内核态缓冲区拷贝
到用户空间

所以综上所述,整个过程分为如下两个大过程

1. IO调用阶段: 应用程序进程向内核发起系统调用
2. IO执行阶段: 内核执行IO操作并返回
    2.1 准备数据阶段: 内核等待IO设备准备好数据
    2.2 拷贝数据阶段: 将数据从内核缓冲区复制到用户空间缓冲区

### BIO 同步阻塞IO模型

程序进程发起内核调用->准备数据阶段->拷贝数据阶段,在整个过程中发起系统调用的线程一直都属阻塞状态,不撞南墙不回头的架势,
有的同学也许会说,我可以起多个进程或者线程来调用啊,是的,可以起到一定程度的效果,但是线程多了,别忘了线程或者进程之间的上下文切换
可是非常耗时的操作,BIO的一个关键性能点就是**阻塞**二字

### NIO 同步非阻塞模型

关键问题是运行的进程阻塞问题,如果发起内核调用的时候可以立马返回,结束本次调用,那不就是可以给进程一些喘息的机会了么?
等下次这次IO状态查询再次发起一次调用即可.也就是**轮询来让IO数据准备阶段变为不阻塞**,一旦某次请求数据准备好了,这时候进程
要阻塞的等待IO执行拷贝数据的阶段执行完毕然后处理数据报即可.

随之而来的问题就是我们设想我们同事发起了1000次IO请求,这个时候单位时间内可能有1000个请求发出去了,但是可能只有2个准备好了,可以阻塞的等待
下个阶段的数据拷贝,那么其他998次请求都是无效的,这不是非常可耻的.但不得不说想




# NIO 学习
NIO是非阻塞IO模型,其中要掌握的重点包括如下三点:

- buffer 缓冲区
- channel 通道
- selector 多路复用器

首先介绍缓冲区的概念,Buffer是NIO模型中重要的数据介质,不同于普通的IO流,必须完全一下子读取或者写入,NIO在读取数据,写入数据时都是面向缓冲区进行操作的, 缓冲区实质是一个数组