    @(InterView)[多线程]

###java多线程总结

@(InterView)

>一句话总结多线程： 一条线程是进程中的一个顺序的控制流，一个进程可以有一个或者多个线程，每条线程并行执行多个任务，能够满足程序员编写高效率的代码来达到充分利用CPU的目的？
>**进程是啥？**一个进程包括操作系统分配的内存空间、包含一个或者多个线程。线程必须依赖进程的存在

****
####一.如何New一个新线程
在java中要想实现多线程，有两种手段，
**一种是继承Thread类，**（详见 我的Interview项目 thread包下的 NewThread1.java）
**另外一种是实现Runable接口.**（详见 我的Interview项目 thread包下的 NewThread2.java）
(其实准确来讲，应该有三种，还有一种是实现Callable接口，并与Future、线程池结合使用，此文这里不讲这个，有兴趣看这里) [Java并发编程与技术内幕:Callable、Future、FutureTask、CompletionService ](http://blog.csdn.net/evankaka/article/details/51610635)
####二.关于线程的状态改变
**线程的状态示意图：**
![Alt text](http://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg "optional title")
* 新建状态： 
使用new关键字新建一个Thread类或者其子类的对象后，该线程就处于新建状态，程序调用start（）方法之前线程会一直保持新建状态。
* 就绪状态：
当线程对象调用了start（）方法之后，该线程就进入就绪状态，就绪状态的线程会在就绪队列中等待，等待JVM里边的线程调度器的调度。
* 运行状态：
如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
* **阻塞状态:**
如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：

1. 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。

2. 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。

3. 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
* 死亡状态：
一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

**线程的状态示意图（详细版本）：**
![Alt text](http://incdn1.b0.upaiyun.com/2016/08/665f644e43731ff9db3d341da5c827e1.png "optional title")
1. 调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。
 
Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：
>[plain] view plain copy
static int MAX_PRIORITY  
          线程可以具有的最高优先级，取值为10。  
static int MIN_PRIORITY  
          线程可以具有的最低优先级，取值为1。  
static int NORM_PRIORITY  
          分配给线程的默认优先级，取值为5。  

Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。
 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。
线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。
JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。
 
2. 线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。
 
3. 线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样。
 
4. 线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。
 
5. 线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
 
6.  线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。
 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。